from util import pe_patched_handle, decrypt_block, decrypt
from Crypto.Util.number import bytes_to_long
import pefile, string

DLLs = [
    'kernel32.dll',
    'msvcrt.dll',
    'shlwapi.dll',
    'ntdll.dll',
    'advapi32.dll'
    ]

URL = 'C:\\Windows\\System32\\'

# sub_401000
def adler32(data, start_value=0xffffffff):
    arg2 = len(data)
    c1 = start_value >> 16
    c2 = start_value & 0xffff
    while arg2:
        dsize = min(arg2, 0x15b0)
        arg2 -= dsize
        for i in range(dsize):
            c2 += data[i]
            c1 += c2
        c1 %= 0xfff1
        c2 %= 0xfff1
    return (c1 << 16) | c2

# sub_4017AE
def resolve_hash(dll, target):
    pe = pefile.PE(URL+dll)
    for sym in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        name = sym.name
        if name:
            hsh = adler32(name)
            if hsh == target:
                return name.decode()

def resolve_dll_and_functions_by_hash(target_dll_hash, target_function_hashes):
    for dll in DLLs:
        if adler32(dll.lower().encode('utf-16')[2:]) == target_dll_hash:
            print(f'[+] found target dll => {dll}')
            break

    for h in target_function_hashes:
        print(f'[+] 0x{h:x} => {resolve_hash(dll, h)}')

# strongly related to sub_401867
def decrypt_function_names(debug=False):
    data_section = pe_patched_handle.sections[3].get_data().split(b'\xff'*4)[0]
    data_section = data_section[0x0c:]  # skip first 12 bytes
    api_num = [47, 44, 23, 8, 13, 6, 2, 5, 4, 8, 6, 1, 4, 2] # extracted from function 0x4018D1
    api_idx = api_num.copy()
    c = 0
    decrypted = -1
    fnames = []

    while True:
        size = bytes_to_long(data_section[c:c+4][::-1])
        enc_data = data_section[c+4:c+4+size]
        data = decrypt(enc_data, size)[:-1]

        if not all(0x20 < d < 0x80 for d in data):
            break
        
        decrypted += 1
        data = data.decode()
        if not decrypted:
            if debug:
                print(f'[+] decrypted dll => {data}.dll (total={api_num[0]})')
        else:    
            if decrypted <= api_idx[0]:
                if debug:
                    print(f'\t[+] decrypted function => {data}')
                fnames.append(data)
                if decrypted == api_idx[0]:
                    decrypted = -1
                    api_idx = api_idx[1:]
        
        c += 4 + size

    return fnames

def ida_auto_naming(start, end, fnames):
    fnames.reverse()
    for addr in range(start, end, 4):
        if idaapi.get_name(addr) == '':
            # skip alignment bytes
            continue
        idaapi.set_name(addr, fnames.pop())

if __name__ == '__main__':
    target_dll_hash = 0x3B98045E                        # extracted from sub_4018D1
    target_function_hashes = [0x1E2B04A4, 0x288B0588]   # extracted from sub_4018D1
    
    #resolve_dll_and_functions_by_hash(target_dll_hash, target_function_hashes)
    fnames = decrypt_function_names()
    start, end = (0x40f658, 0x40f940)

    # the function below has to be executed inside IDA
    #ida_auto_naming(start, end, fnames)