from util import pe_patched_handle, decrypt_block, decrypt
from Crypto.Util.number import bytes_to_long
from aplib import decompress
import os

base = 0x40c000

data_section = pe_patched_handle.sections[3].get_data().split(b'\xff'*4)[0]

addr = 0
while addr < len(data_section):
    size = bytes_to_long(data_section[addr:addr+4][::-1])   # extract encrypted data size
    enc_data = data_section[addr+4:addr+4+size] # extract the encrypted data
    data = decrypt(enc_data, size)
    
    try:
        # try utf-8 decoding
        data = data.decode()
    except:
        try:
            # if utf-8 decode fails, then try utf-32 (utf-16 could work too)
            data = data.decode('utf-32')
        except:
            pass
    
    va = base+addr+4
    # found manually that these VAs need to be decompressed after decrypted
    if va in [0x40d073, 0x40e8d6]:
        data = decompress(data)
        if not os.path.exists('dropped'):
            if data[:3] == b'MZ\x90':
                with open('dropped', 'wb') as f:
                    f.write(data)

    # debloat output
    if type(data) == bytes and len(data) > 300:
        data = data[:300] + b' ... REDACTED ...'

    print(f'[+] 0x{va:x} => {data}')
    
    addr += 4 + size